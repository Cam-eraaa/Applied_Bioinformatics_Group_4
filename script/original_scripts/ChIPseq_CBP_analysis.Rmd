---
title: "ChIPseq analysis"
author: "Jenny Jakobsson"
date: "11/11/2020"
output: html_document

params:
  workingDir: ~/Applied_Bioinformatics_Group_4
  dataDir: data_johan/data/ChIPseq
  RscriptsDir: script/original_scripts
  chipSeqData: CBP/CBP-CBP_dm6.featureCount.count.tab.txt
  resultsDir: results/original_method/ChIPseq
  Antibody: CBP
  ChIPresultsDir: results/original_method/ChIPseq/CBP
  ChIPSeq.data: ChIPseq.CBP.data.tsv
---

```{r setup, include=FALSE}
# Install required packages (Only needs to be run once)
#install.packages("kableExtra")
#install.packages("tidyverse")
#install.packages("RColorBrewer")
#install.packages("BiocManager")
#install.packages("pheatmap")
#install.packages("GGally")
#BiocManager::install("DESeq2")
#BiocManager::install("edgeR")


# Include the functions from the expression analysis script
source(paste(params$workingDir, params$RscriptsDir, "ExpressionAnalysisFunctions.r",sep = "/"))

# Load the installed packages
library(tidyverse)
library(gplots)
library(knitr)
library(kableExtra)
library("viridis")
library(RColorBrewer)
library(DESeq2)
library(edgeR)
library("pheatmap")

knitr::opts_chunk$set(echo = TRUE)
```

# ChIPseq CBP data analysis
## Comparing mapping pattern between the samples
The evaluation is done by the output from PROseq which is read counts per CBP peak region

## Loading data
We load the count table of the potential enhancers per CBP peak. This is the reads from PROseq. The countdata is converted into a dataframe with the columns 

```{r Adding the first analysis of the data ,message=FALSE ,warning = FALSE}
#Load in the path to the CBP featureCount file
featureCountFile = paste(params$workingDir, params$dataDir, params$chipSeqData, sep = "/")

#Load the featurecount file into a table
FCdata = read.table(file = featureCountFile, header = TRUE, sep = "\t", quote = "", stringsAsFactors = FALSE)

#Select the geneID, chromosome, start, end, strand and length. 
peakInfo  = FCdata [,1:6]
peakInfo = peakInfo %>% dplyr::rename(geneID = Geneid)


#Select the rest of the columns from the featureCount file, the counts. 
countData = FCdata[,-1:-6]
rownames(countData) = peakInfo$geneID
```

## Create sample information

Extracting the information from the sample name so it is more easily accessible in a data frame. The sample information is sample name, mutant, time, replicate and bam file name.

```{r sample info ,message=FALSE ,warning = FALSE}
#Rename the labels for the labels in countData so that they just have the mutant name and replicate and input/CBP
samples = colnames(countData)
samples = gsub(pattern = "..CBP_ChIP_seq_mapped.CBP_toll_dm6only.bam_dm6.", replacement = "", x = samples)
samples = gsub(pattern = ".dm6.bowtie2.sorted.bam", replacement = "", x = samples)
colnames(countData) = samples

#Create a table with more information about the samples and create good names
sampleInfo = data.frame(sampleName = colnames(countData), sampleInfo = samples, stringsAsFactors = F)
sampleInfo= sampleInfo %>% separate(sampleInfo, c("Genotype", "Replicate", "Input", "sample"), sep = "_", remove = F)
sampleInfo$Genotype = recode(sampleInfo$Genotype, toll910 = "Toll9")
sampleInfo$Genotype = recode(sampleInfo$Genotype, gd7 = "Gd7")
sampleInfo$Genotype = recode(sampleInfo$Genotype, toll10B = "Toll10b")
sampleInfo$sampleID = paste(sampleInfo$Genotype, sampleInfo$Replicate, sampleInfo$Input , sep = "_")

#Make sure that CountData only contains the samples that has names in sampleName and change the name in countData
countData = countData[,sampleInfo$sampleName]
colnames(countData) = sampleInfo$sampleID
```

## Filtering


```{r differential gene expression analysis ,message=FALSE ,warning = FALSE}
#Expression data is now the count data and meta info is the info about the samples. 
exp.data = countData
metaInfo = sampleInfo

#Change the rownames to the names that inform on the mutant, replicate and CPB/input
rownames(metaInfo) = sampleInfo$sampleID

#Convert some of the columns to factors
metaInfo$Genotype = as.factor(metaInfo$Genotype)
metaInfo$sampleID = as.factor(metaInfo$sampleID)
metaInfo$Input = as.factor(metaInfo$Input)

#Create a DESeq dataset
dds <- DESeqDataSetFromMatrix(countData = exp.data,
                               colData = metaInfo, ~1)

#Remove rows with low counts and normalize samples for visualization
dds <- dds[ rowSums(counts(dds)) > 100, ] #This was 100

#Look at the dimension of the data set. 
dim(dds)

#Calculate the reads per kilobase million from the count data. 
test2 = rpkm(countData, gene.length = peakInfo$Length)

#Use a function from ExpressionAnalysisFucntions.r that plots a heat map. 
plotSample2SampleDistance(test2)

#Transform the count data in the DESeq data frame to the log2 scale which minimizes differences between samples for rows with small counts, and which normalizes with respect to library size
rld <- rlog(dds)

#Put this normalized data into a data frame
normExpression = as.data.frame(assay(rld))

#Create a normalized expression data frame
normExpression$geneID = rownames(normExpression)
normExpressionDF  = normExpression %>% gather( key = sampleID, value = rlog, -geneID)
normExpressionDF = inner_join(normExpressionDF, metaInfo)
head(normExpressionDF)

#normExpressionDF = inner_join(normExpressionDF, sampleInfo)

#Plot the CBP and input samples as one line each
ggplot(normExpressionDF, aes(x = rlog, color = Input)) + geom_density()

peakInfo1 = normExpressionDF %>% dplyr::select(geneID, rlog, sampleName) %>% 
  dplyr::group_by (geneID) %>%
  dplyr::summarize ( min = min(rlog), max = max(rlog), mean = mean(rlog), sd = sd(rlog), overQC = length(which(rlog > 5)) ) 

#Filter out so that peakInfo.QC only has overQC values above 2. 
peakInfo.QC = peakInfo1 %>% filter(overQC > 2)
#Filter so that normExpressionDF.QC only contains elements with a geneID that also is in peakInfo.QC
normExpressionDF.QC = normExpressionDF %>% filter(geneID %in% peakInfo.QC$geneID)

#Plot the filtered normExpressionDF, but coloring sampleName now
ggplot(normExpressionDF.QC, aes(x = rlog, color = sampleName)) + geom_density()

#Filter to only contain CBP and not Input. 
normExpressionDF.QC.CBP = normExpressionDF.QC %>% filter(Input == params$Antibody)
normExpression.QC = normExpressionDF.QC.CBP %>%
  dplyr::select(geneID, sampleName, rlog) %>% 
  spread(key = sampleName, value = rlog)

rownames(normExpression.QC) = normExpression.QC$geneID
normExpression.QC = normExpression.QC[, -1]



```



```{R  check the normalised data  ,message=FALSE ,warning = FALSE}

#Plot a new heat map with only CBP 
plotSample2SampleDistance(normExpression.QC)

#Do a PCA analysis
mir.pca <- prcomp(t(normExpression.QC), center = TRUE, scale = FALSE) 
#Calculate evar from the PCA output
e.var = (mir.pca[['sdev']]^2 / sum(mir.pca[['sdev']]^2))
#Make e.var to a data frame
e.var = as.data.frame( e.var )
#Add column named PC 
e.var$PC = as.factor(1:nrow(e.var))
#Add column with the varience
e.var$Variance = e.var$e.var*100
#Add column with CumulativeVariance
e.var$CumulativeVariance = cumsum(e.var$Variance)
#Plot each PC component and its varience. 
qplot(PC, Variance, data=e.var, geom = c("point")
      , ylim = c(0,max(e.var$Variance)+5) 
      ,ylab = "Variance (%)")




#Make the first 5 PCA output to a data frame. 
pctable = as.data.frame(mir.pca$x)[, 1:5]
#Add column with sample name
pctable$sampleName = rownames(pctable)
#Add the metainfo
pctable = inner_join(pctable, metaInfo)

#Plot using a function in ExpressionAnalysisFucntions
test  = plotPCAplot(PCAinfo = pctable, n.comp = 4,
            varianceInfo = e.var, 
            colorComponent = "Genotype",pchComponent = "Replicate"
              
)

test

mean = pctable %>% dplyr::select(PC1,PC2,PC3,Genotype) %>%
  dplyr::group_by(Genotype) %>%
  dplyr::summarise(PC1 = mean(PC1) ,PC2 = mean(PC2), PC3 = mean(PC3) )

origo = data.frame(PC1=0, PC2=0, PC3 = 0)

line.gd7 = rbind(mean[1,2:4],origo,-mean[1,2:4])
line.gd7$factor = "Gd7"
line.toll10b = rbind(mean[2,2:4],origo,-mean[2,2:4])
line.toll10b$factor = "Toll10b"
line.toll9 = rbind(mean[3,2:4],origo,-mean[3,2:4])
line.toll9$factor = "Toll9"

line = rbind(line.gd7,line.toll10b,line.toll9)

ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype))

ggplot(line, mapping = aes(x = PC1,y = PC2, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC1,y = PC2, color = Genotype))

ggplot(line, mapping = aes(x = PC1,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC1,y = PC3, color = Genotype))

```
##Try to use create loading scores and the tsv files we need

```{r convert loadings to the factor Scores}
# Saves the loading scores for PC1-PC3
line = rbind(line.gd7,line.toll10b,line.toll9)
loadings =mir.pca$rotation[,1:3]

# Converts the loading values by subtracting the column(PC) mean and dividing by the column(PC) standard deviation. The columns needs to be transposed to rows to calculate and are then transposed back to columns
loadings_norm = as.data.frame(t((t(loadings)-colMeans(loadings))/colSds(loadings)))
loadings_norm$geneID = rownames(loadings)

distance3d <- function(a,b){
  v1 = a - b
  
  distance = ((v1[[1]]^2 + v1[[2]]^2 + v1[[3]]^2)^0.5)
  return(distance)
}

dist3d <- function(point,b,c) {
  v1 <- b - c
  v2 <- point - b      
  v3 <- cross3d_prod(v1,v2)
  area <- sqrt(sum(v3*v3))/2
  d <- 2*area/sqrt(sum(v1*v1))
  return(d)
}

cross3d_prod <- function(v1,v2){
  v3 <- vector()
  v3[1] <- v1[2]*v2[3]-v1[3]*v2[2]
  v3[2] <- v1[3]*v2[1]-v1[1]*v2[3]
  v3[3] <- v1[1]*v2[2]-v1[2]*v2[1]
  return(v3)
}

loadings_new = loadings_norm
for(j in unique(line$factor)){
  loadings_new[[j]]=0
  for(i in 1:nrow(loadings_norm)){
  line1 = line %>% dplyr::filter(factor == j) %>% dplyr::select(PC1,PC2,PC3)
  loadings_new[i,j] = dist3d(b =as.numeric(line1[1,]),
                            c = as.numeric(line1[3,]),
                            point = as.numeric(loadings_new[i,1:3]))

  }

}

  
loadingsDF = gather(loadings_new, key = PC, value = Loading, -geneID )

ggplot(loadingsDF, mapping = aes(x = Loading, color = PC )) + geom_density() 

# Recreates the same data fram as loadings_new but in another column order
loadingsDF.all = loadingsDF %>%  spread(key = PC, value = Loading)

tmp = loadingsDF.all
tmp$distance =  ((tmp$PC1^2 + tmp$PC2^2 + tmp$PC3^2)^0.5)
loadingsDF.all = tmp


loadingsDF.all.factorDistance =loadingsDF.all %>% gather(key = factor, value = distance2Factor,Gd7,Toll10b,Toll9 )

loadingsDF.all.factorDistance$distanceFactor = sqrt(loadingsDF.all.factorDistance$distance^2 -
                                                   loadingsDF.all.factorDistance$distance2Factor^2)

loadingsDF.all.factorDistance$distanceFactor[is.na(loadingsDF.all.factorDistance$distanceFactor)] = 0

loadingsDF.all.factorDistance$direction = "Down"
line$Dir = rep(c("Up","origo","Down"), 3)


for(i in 1:nrow(loadingsDF.all.factorDistance)){
  factor2 = loadingsDF.all.factorDistance[i,]$factor
  UpPoint = line %>% dplyr::filter(factor == factor2 & Dir == "Up") %>% dplyr::select(PC1,PC2,PC3)
  DownPoint = line %>% dplyr::filter(factor == factor2 & Dir == "Down") %>% dplyr::select(PC1,PC2,PC3)
  point = loadingsDF.all.factorDistance[i,c("PC1","PC2","PC3")]
  up = distance3d(as.numeric( UpPoint),as.numeric(point))
  down = distance3d(as.numeric(DownPoint),as.numeric(point))
  
  if(up < down){
    loadingsDF.all.factorDistance[i,"direction"] = "Up"
  }else{
    loadingsDF.all.factorDistance[i,"distanceFactor"] = 
      -loadingsDF.all.factorDistance[i,"distanceFactor"]
  }
}

loadingsDF.all.factorDistance2 = loadingsDF.all.factorDistance %>% dplyr::select( geneID,PC1, PC2,PC3, distance, factor,distanceFactor) %>% spread( key = factor, value = distanceFactor)


loadingsDF.all.factorDistance.max = loadingsDF.all.factorDistance %>% group_by(geneID) %>% summarise(max = max(abs(distanceFactor)))
 
loadingsDF.all.factorDistance$max=abs(loadingsDF.all.factorDistance$distanceFactor) 

loadingsDF.all.factorDistance.max = inner_join(loadingsDF.all.factorDistance,loadingsDF.all.factorDistance.max) %>%
  dplyr::select(geneID, factor, direction)

loadingsDF.all.factorDistance.max.peakInfo = inner_join (peakInfo,loadingsDF.all.factorDistance.max)

loadingsDF.all.factorDistance.max.peakInfo = inner_join(
  loadingsDF.all.factorDistance.max.peakInfo,
  loadingsDF.all.factorDistance2
)

loadingsDF.all.factorDistance.max.peakInfo2 = 
  loadingsDF.all.factorDistance.max.peakInfo %>%
  dplyr::select(-PC1,-PC2,-PC3,-distance)


fileNameChIPseq = paste( params$workingDir, params$ChIPresultsDir,  
                        params$ChIPSeq.data,
                             sep = "/")
write.table(x = loadingsDF.all.factorDistance.max.peakInfo2, file = fileNameChIPseq,
                  quote = F, sep = "\t", col.names = T, row.names = F) 
```

### Print ChIPseq data to file

```{r save the files ,message=FALSE ,warning = FALSE}
sampleInfoFile = paste(
  params$workingDir,
  params$resultsDir,
  params$Antibody,
  "CBP.CBP.sampleInfo.QC.tab.txt",
  sep = "/"
)
sampleInfo.QC = sampleInfo %>%
  filter (Input == params$Antibody) %>%
  select(sampleInfo, sampleID, Genotype, Replicate, Input)
write.table(
  x = sampleInfo.QC,
  file = sampleInfoFile,
  quote = F,
  sep =  "\t",
  row.names = F,
  col.names = T
)

peakTableFile = paste(
  params$workingDir,
  params$resultsDir,
  params$Antibody,
  "CBP.CBP.peak.QC.tab.txt",
  sep = "/"
)
write.table(
  x = peakInfo.QC,
  file = peakTableFile,
  quote = F,
  sep =  "\t",
  row.names = F,
  col.names = T
)

countData.QC = countData[peakInfo.QC$geneID, sampleInfo.QC$sampleID]
countTableFile = paste(
  params$workingDir,
  params$resultsDir,
  params$Antibody,
  "CBP.CBP.counts.QC.tab.txt",
  sep = "/"
)
write.table(
  x = countData.QC,
  file = countTableFile,
  quote = F,
  sep =  "\t",
  row.names = T,
  col.names = T
)

rlogTableFile = paste(
  params$workingDir,
  params$resultsDir,
  params$Antibody,
  "CBP.CBP.rlog.QC.tab.txt",
  sep = "/"
)
rlogExpression.QC = normExpression[peakInfo.QC$geneID, sampleInfo.QC$sampleID]
write.table(
  x = rlogExpression.QC,
  file = rlogTableFile,
  quote = F,
  sep =  "\t",
  row.names = T,
  col.names = T
)
```



