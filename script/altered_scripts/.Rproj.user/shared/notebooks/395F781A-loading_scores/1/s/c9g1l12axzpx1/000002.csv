"0","# Saves the loading scores for PC1-PC3"
"0","line = rbind(line.gd7,line.toll10b,line.toll9, line.time)"
"0","loadings =mir.pca$rotation[,1:3]"
"0",""
"0","# Converts the loading values by subtracting the column(PC) mean and dividing by the column(PC) standard deviation. The columns needs to be transposed to rows to calculate and are then transposed back to columns"
"0","loadings_norm = as.data.frame(t((t(loadings)-colMeans(loadings))/colSds(loadings)))"
"0","loadings_norm$Geneid = rownames(loadings)"
"0",""
"0","distance3d <- function(a,b){"
"0","  v1 = a - b"
"0","  "
"0","  distance = ((v1[[1]]^2 + v1[[2]]^2 + v1[[3]]^2)^0.5)"
"0","  return(distance)"
"0","}"
"0",""
"0",""
"0","dist3d <- function(point,b,c) {"
"0","  v1 <- b - c"
"0","  v2 <- point - b      "
"0","  v3 <- cross3d_prod(v1,v2)"
"0","  area <- sqrt(sum(v3*v3))/2"
"0","  d <- 2*area/sqrt(sum(v1*v1))"
"0","  return(d)"
"0","}"
"0",""
"0","cross3d_prod <- function(v1,v2){"
"0","  v3 <- vector()"
"0","  v3[1] <- v1[2]*v2[3]-v1[3]*v2[2]"
"0","  v3[2] <- v1[3]*v2[1]-v1[1]*v2[3]"
"0","  v3[3] <- v1[1]*v2[2]-v1[2]*v2[1]"
"0","  return(v3)"
"0","}"
"0",""
"0","loadings_new = loadings_norm"
"0","for(j in unique(line$factor)){"
"0","  loadings_new[[j]]=0"
"0","  for(i in 1:nrow(loadings_norm)){"
"0","  line1 = line %>% dplyr::filter(factor == j) %>% dplyr::select(PC1,PC2,PC3)"
"0","  loadings_new[i,j] = dist3d(b =as.numeric(line1[1,]),"
"0","                            c = as.numeric(line1[3,]),"
"0","                            point = as.numeric(loadings_norm[i,1:3]))"
"0",""
"0","  }"
"0",""
"0","}"
"0",""
"0","  "
"0","loadingsDF = gather(loadings_new, key = PC, value = Loading, -Geneid )"
"0",""
"0","ggplot(loadingsDF, mapping = aes(x = Loading, color = PC )) + geom_density() "
