overQC = length(which(rlog > 5))
)
geneInfo.QC2 = geneInfo %>%
filter(overQC > 2)
normExpressionDF.QC = normExpressionDF %>%
filter(geneID %in% geneInfo.QC2$geneID)
ggplot(normExpressionDF.QC, aes(x = rlog, color = sampleName)) + geom_density()
normExpression.QC = normExpressionDF.QC %>%
dplyr::select(geneID, sampleName, rlog) %>%
spread(key = sampleName, value = rlog)
rownames(normExpression.QC) = normExpression.QC$geneID
normExpression.QC = normExpression.QC[, -1]
## Saving sampleInfo File
sampleInfoFile = paste(params$workingDir,
params$resultsDir,
"ATAC.sampleInfo.QC.tab.txt",
sep = "/")
write.table(
x = sampleInfo_Mutants,
file = sampleInfoFile,
quote = F,
sep =  "\t",
row.names = F,
col.names = T
)
## Saving peakInfo File
peakInfo_QC = peakInfo %>%
dplyr::rename(geneID = Geneid) %>%
inner_join(geneInfo.QC2)
peakTableFile = paste(params$workingDir,
params$resultsDir,
"ATAC.CBP.peaks.QC.tab.txt",
sep = "/")
write.table(
x = peakInfo_QC,
file = peakTableFile,
quote = F,
sep =  "\t",
row.names = F,
col.names = T
)
count_ATAC_QC_File = paste(params$workingDir,
params$resultsDir,
paste(params$count_ATAC_QC, sep = "."),
sep = "/")
countData.QC = countData_mutants[peakInfo_QC$geneID,
sampleInfo_Mutants$SampleInfo]
write.table(
x = countData.QC,
file = count_ATAC_QC_File,
quote = F,
sep =  "\t",
row.names = T,
col.names = T
)
## Saving normalised count file
NormalisedCountFile = paste(
params$workingDir,
params$resultsDir,
paste(params$normalisedATACpeakData, sep = "."),
sep = "/"
)
normExpression.QC = normExpression[peakInfo_QC$geneID, sampleInfo_Mutants$SampleInfo]
write.table(
x = normExpression.QC,
file = NormalisedCountFile,
quote = F,
sep = "\t",
col.names = T,
row.names = T
)
knitr::opts_chunk$set(echo = TRUE)
# Load the functions script (for plotting)
source(
paste(
params$workingDir,
params$RscriptsDir,
"ExpressionAnalysisFunctions.r",
sep = "/"
)
)
library(tidyverse)
library(gplots)
library(kableExtra)
library(DESeq2)
library("viridis")
# Load the sample info
sampleInfoFile = paste(params$workingDir, params$resultsDir, params$ATACSampleInfo,
sep = "/")
sampleInfo = read.table(sampleInfoFile,
header = TRUE,
sep = "\t",
quote = "",
stringsAsFactors = FALSE
)
# Load the rlog values
normexpression_file = paste(params$workingDir,
params$resultsDir,
params$normalisedATACpeakData,
sep = "/")
normExpression.QC = read.table(
normexpression_file,
header = TRUE,
sep = "\t",
quote = "",
stringsAsFactors = FALSE
)
plotSample2SampleDistance(normExpression.QC)
#'  __Figure 1 Plotting sample to sample distance__ .
#'  0 means that they are identical and 1 means that they are totally different.
#'  The darker the blue the more similair. Also dendogram shows how similair they are.
#'
#' Samples do not cluster according to pre an post op. Most likely more due to difference in mapping (technical problem)
#'
#' #### PCA analysis
#' Running PCA on the samples and plotting the different variables to see which of the parameterrs that fit the different components the best.
#'
#' First checking how much the different PC contribute.
mir.pca <- prcomp(t(normExpression.QC), center = TRUE, scale = FALSE)
e.var = (mir.pca[['sdev']]^2 / sum(mir.pca[['sdev']]^2))
e.var = as.data.frame( e.var )
e.var$PC = as.factor(1:nrow(e.var))
e.var$Variance = e.var$e.var*100
e.var$CumulativeVariance = cumsum(e.var$Variance)
qplot(PC, Variance, data=e.var, geom = c("point")
, ylim = c(0,max(e.var$Variance)+5)
,ylab = "Variance (%)")
#'  __Figure 2 Plotting PCA variance__.
#'  Displays how much each of the PC contributes to the overall expression.
#'  This suggest that the two first PC explains most of the variation.
#'
#+ save2, include=FALSE
#ggsave(paste(params$workingDirectory,params$resultsDirectory, "PCAvariance.png", sep = "/"))
#'
#'
pctable = as.data.frame(mir.pca$x)[, 1:5]
pctable = cbind(pctable, sampleInfo)
test  = plotPCAplot(PCAinfo = pctable, n.comp = 4,
varianceInfo = e.var,
colorComponent = "Genotype",pchComponent = "Time"
)
test
mean = pctable %>% dplyr::select(PC1,PC2,PC3,Genotype) %>%
dplyr::group_by(Genotype) %>%
dplyr::summarise(PC1 = mean(PC1) ,PC2 = mean(PC2), PC3 = mean(PC3) )
# Changes here to include PC1
origo = data.frame(PC1=0,PC2=0, PC3 = 0)
line.gd7 = rbind(mean[1,2:4],origo,-mean[1,2:4])
line.gd7$factor = "Gd7"
line.toll10b = rbind(mean[2,2:4],origo,-mean[2,2:4])
line.toll10b$factor = "Toll10b"
line.toll9 = rbind(mean[3,2:4],origo,-mean[3,2:4])
line.toll9$factor = "Toll9"
line = rbind(line.gd7,line.toll10b,line.toll9)
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
loadings =mir.pca$rotation[,1:3]
loadings1 = as.data.frame(t((t(loadings)-colMeans(loadings))/colSds(loadings)))
loadings1$Geneid = rownames(loadings)
#loadings1 = as.data.frame(loadings)
distance3d <- function(a,b){
v1 = a - b
distance = ((v1[[1]]^2 + v1[[2]]^2 + v1[[3]]^2)^0.5)
return(distance)
}
dist3d <- function(point,b,c) {
v1 <- b - c
v2 <- point - b
v3 <- cross3d_prod(v1,v2)
area <- sqrt(sum(v3*v3))/2
d <- 2*area/sqrt(sum(v1*v1))
return(d)
}
cross3d_prod <- function(v1,v2){
v3 <- vector()
v3[1] <- v1[2]*v2[3]-v1[3]*v2[2]
v3[2] <- v1[3]*v2[1]-v1[1]*v2[3]
v3[3] <- v1[1]*v2[2]-v1[2]*v2[1]
return(v3)
}
for(j in unique(line$factor)){
loadings1[[j]]=0
for(i in 1:nrow(loadings1)){
line1 = line %>% dplyr::filter(factor == j) %>% dplyr::select(PC1,PC2,PC3)
loadings1[i,j] = dist3d(b =as.numeric(line1[1,]),
c = as.numeric(line1[3,]),
point = as.numeric(loadings1[i,1:3]))
}
}
View(loadings)
loadingsDF = gather(loadings1, key = PC, value = Loading, -Geneid )
ggplot(loadingsDF, mapping = aes(x = Loading, color = PC )) + geom_density()
loadingsDF.all = loadingsDF %>%  spread(key = PC, value = Loading)
tmp = loadingsDF.all
tmp$distance =  ((tmp$PC1^2 + tmp$PC2^2 + tmp$PC3^2)^0.5)
loadingsDF.all = tmp
#loadingsDF.all.factorDistance =loadingsDF.all %>% gather(key = factor, value = distance2Factor,Time,Gd7,Toll10b,Toll9 )
loadingsDF.all.factorDistance =loadingsDF.all %>% gather(key = factor, value = distance2Factor,Gd7,Toll10b,Toll9 )
loadingsDF.all.factorDistance$distanceFactor = sqrt(loadingsDF.all.factorDistance$distance^2 -
loadingsDF.all.factorDistance$distance2Factor^2)
loadingsDF.all.factorDistance$distanceFactor[is.na(loadingsDF.all.factorDistance$distanceFactor)] = 0
loadingsDF.all.factorDistance$direction = "Down"
line$Dir = rep(c("Up","origo","Down"), 4)
loadingsDF.all.factorDistance =loadingsDF.all %>% gather(key = factor, value = distance2Factor,Time,Gd7,Toll10b,Toll9 )
View(loadings1)
View(loadings)
View(mir.pca)
plotSample2SampleDistance(normExpression.QC)
mir.pca$rotation
View(loadings)
View(loadings1)
loadings1 = as.data.frame(t((t(loadings)-colMeans(loadings))/colSds(loadings)))
View(loadings1)
View(loadings)
View(loadings)
View(loadings1)
loadings2 =mir.pca$x
View(loadings2)
loadings2 =mir.pca$center
loadings2 =mir.pca$center[,1]
loadings2 =mir.pca$center[,1:3]
loadings2 =mir.pca$center[1]
knitr::opts_chunk$set(echo = TRUE)
# Load the functions script (for plotting)
source(
paste(
params$workingDir,
params$RscriptsDir,
"ExpressionAnalysisFunctions.r",
sep = "/"
)
)
library(tidyverse)
library(gplots)
library(kableExtra)
library(DESeq2)
library("viridis")
# Load the sample info
sampleInfoFile = paste(params$workingDir, params$resultsDir, params$ATACSampleInfo,
sep = "/")
sampleInfo = read.table(sampleInfoFile,
header = TRUE,
sep = "\t",
quote = "",
stringsAsFactors = FALSE
)
# Load the rlog values
normexpression_file = paste(params$workingDir,
params$resultsDir,
params$normalisedATACpeakData,
sep = "/")
normExpression.QC = read.table(
normexpression_file,
header = TRUE,
sep = "\t",
quote = "",
stringsAsFactors = FALSE
)
plotSample2SampleDistance(normExpression.QC)
#'  __Figure 1 Plotting sample to sample distance__ .
#'  0 means that they are identical and 1 means that they are totally different.
#'  The darker the blue the more similar. Also dendogram shows how similar they are.
#'
#' Samples do not cluster according to pre an post op. Most likely more due to difference in mapping (technical problem)
#'
#' #### PCA analysis
#' Running PCA on the samples and plotting the different variables to see which of the parameters that fit the different components the best.
#'
#' First checking how much the different PC contribute.
mir.pca <- prcomp(t(normExpression.QC), center = TRUE, scale = FALSE)
e.var = (mir.pca[['sdev']]^2 / sum(mir.pca[['sdev']]^2))
e.var = as.data.frame( e.var )
e.var$PC = as.factor(1:nrow(e.var))
e.var$Variance = e.var$e.var*100
e.var$CumulativeVariance = cumsum(e.var$Variance)
qplot(PC, Variance, data=e.var, geom = c("point")
, ylim = c(0,max(e.var$Variance)+5)
,ylab = "Variance (%)")
#'  __Figure 2 Plotting PCA variance__.
#'  Displays how much each of the PC contributes to the overall expression.
#'  This suggest that the two first PC explains most of the variation.
#'
#+ save2, include=FALSE
#ggsave(paste(params$workingDirectory,params$resultsDirectory, "PCAvariance.png", sep = "/"))
#'
#'
pctable = as.data.frame(mir.pca$x)[, 1:5]
pctable = cbind(pctable, sampleInfo)
test  = plotPCAplot(PCAinfo = pctable, n.comp = 4,
varianceInfo = e.var,
colorComponent = "Genotype",pchComponent = "Time"
)
test
mean = pctable %>% dplyr::select(PC1,PC2,PC3,Genotype) %>%
dplyr::group_by(Genotype) %>%
dplyr::summarise(PC1 = mean(PC1) ,PC2 = mean(PC2), PC3 = mean(PC3) )
# Changes here to include PC1
origo = data.frame(PC1=0,PC2=0, PC3 = 0)
line.gd7 = rbind(mean[1,2:4],origo,-mean[1,2:4])
line.gd7$factor = "Gd7"
line.toll10b = rbind(mean[2,2:4],origo,-mean[2,2:4])
line.toll10b$factor = "Toll10b"
line.toll9 = rbind(mean[3,2:4],origo,-mean[3,2:4])
line.toll9$factor = "Toll9"
line = rbind(line.gd7,line.toll10b,line.toll9)
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
# Saves the loading scores for PC1-PC3
loadings =mir.pca$rotation[,1:3]
# Converts the loading values by subtracting the column(PC) mean and dividing by the column(PC) standard deviation. The columns needs to be transposed to rows to calculate and are then transposed back to columns
loadings_norm = as.data.frame(t((t(loadings)-colMeans(loadings))/colSds(loadings)))
loadings_norm$Geneid = rownames(loadings)
distance3d <- function(a,b){
v1 = a - b
distance = ((v1[[1]]^2 + v1[[2]]^2 + v1[[3]]^2)^0.5)
return(distance)
}
dist3d <- function(point,b,c) {
v1 <- b - c
v2 <- point - b
v3 <- cross3d_prod(v1,v2)
area <- sqrt(sum(v3*v3))/2
d <- 2*area/sqrt(sum(v1*v1))
return(d)
}
cross3d_prod <- function(v1,v2){
v3 <- vector()
v3[1] <- v1[2]*v2[3]-v1[3]*v2[2]
v3[2] <- v1[3]*v2[1]-v1[1]*v2[3]
v3[3] <- v1[1]*v2[2]-v1[2]*v2[1]
return(v3)
}
for(j in unique(line$factor)){
loadings_new[[j]]=0
for(i in 1:nrow(loadings_norm)){
line1 = line %>% dplyr::filter(factor == j) %>% dplyr::select(PC1,PC2,PC3)
loadings_new[i,j] = dist3d(b =as.numeric(line1[1,]),
c = as.numeric(line1[3,]),
point = as.numeric(loadings_norm[i,1:3]))
}
}
loadings_new = loadings_norm
for(j in unique(line$factor)){
loadings_new[[j]]=0
for(i in 1:nrow(loadings_norm)){
line1 = line %>% dplyr::filter(factor == j) %>% dplyr::select(PC1,PC2,PC3)
loadings_new[i,j] = dist3d(b =as.numeric(line1[1,]),
c = as.numeric(line1[3,]),
point = as.numeric(loadings_norm[i,1:3]))
}
}
View(loadings_norm)
View(loadings_new)
View(line)
View(mean)
origo = data.frame(PC2=0, PC3 = 0)
line.gd7 = rbind(mean[1,3:4],origo,-mean[1,3:4])
line.gd7$factor = "Gd7"
line.toll10b = rbind(mean[2,3:4],origo,-mean[2,3:4])
line.toll10b$factor = "Toll10b"
line.toll9 = rbind(mean[3,3:4],origo,-mean[3,3:4])
line.toll9$factor = "Toll9"
line = rbind(line.gd7,line.toll10b,line.toll9)
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
# Saves the loading scores for PC1-PC3
loadings =mir.pca$rotation[,1:3]
# Converts the loading values by subtracting the column(PC) mean and dividing by the column(PC) standard deviation. The columns needs to be transposed to rows to calculate and are then transposed back to columns
loadings_norm = as.data.frame(t((t(loadings)-colMeans(loadings))/colSds(loadings)))
loadings_norm$Geneid = rownames(loadings)
distance3d <- function(a,b){
v1 = a - b
distance = ((v1[[1]]^2 + v1[[2]]^2 + v1[[3]]^2)^0.5)
return(distance)
}
dist3d <- function(point,b,c) {
v1 <- b - c
v2 <- point - b
v3 <- cross3d_prod(v1,v2)
area <- sqrt(sum(v3*v3))/2
d <- 2*area/sqrt(sum(v1*v1))
return(d)
}
cross3d_prod <- function(v1,v2){
v3 <- vector()
v3[1] <- v1[2]*v2[3]-v1[3]*v2[2]
v3[2] <- v1[3]*v2[1]-v1[1]*v2[3]
v3[3] <- v1[1]*v2[2]-v1[2]*v2[1]
return(v3)
}
loadings_new = loadings_norm
for(j in unique(line$factor)){
loadings_new[[j]]=0
for(i in 1:nrow(loadings_norm)){
line1 = line %>% dplyr::filter(factor == j) %>% dplyr::select(PC1,PC2,PC3)
loadings_new[i,j] = dist3d(b =as.numeric(line1[1,]),
c = as.numeric(line1[3,]),
point = as.numeric(loadings_norm[i,1:3]))
}
}
# Changed here to include PC1
origo = data.frame(PC1=0,PC2=0, PC3 = 0)
line.gd7 = rbind(mean[1,2:4],origo,-mean[1,2:4])
line.gd7$factor = "Gd7"
line.toll10b = rbind(mean[2,2:4],origo,-mean[2,2:4])
line.toll10b$factor = "Toll10b"
line.toll9 = rbind(mean[3,2:4],origo,-mean[3,2:4])
line.toll9$factor = "Toll9"
line = rbind(line.gd7,line.toll10b,line.toll9)
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
ggplot(line, mapping = aes(x = PC1,y = PC2, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC1,y = PC2, color = Genotype, shape = Time))
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
ggplot(line, mapping = aes(x = PC1,y = PC2, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC1,y = PC2, color = Genotype, shape = Time))
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
plotSample2SampleDistance(normExpression.QC)
#'  __Figure 1 Plotting sample to sample distance__ .
#'  0 means that they are identical and 1 means that they are totally different.
#'  The darker the blue the more similar. Also dendogram shows how similar they are.
#'
#' Samples do not cluster according to pre an post op. Most likely more due to difference in mapping (technical problem)
#'
#' #### PCA analysis
#' Running PCA on the samples and plotting the different variables to see which of the parameters that fit the different components the best.
#'
#' First checking how much the different PC contribute.
mir.pca <- prcomp(t(normExpression.QC), center = TRUE, scale = FALSE)
e.var = (mir.pca[['sdev']]^2 / sum(mir.pca[['sdev']]^2))
e.var = as.data.frame( e.var )
e.var$PC = as.factor(1:nrow(e.var))
e.var$Variance = e.var$e.var*100
e.var$CumulativeVariance = cumsum(e.var$Variance)
qplot(PC, Variance, data=e.var, geom = c("point")
, ylim = c(0,max(e.var$Variance)+5)
,ylab = "Variance (%)")
#'  __Figure 2 Plotting PCA variance__.
#'  Displays how much each of the PC contributes to the overall expression.
#'  This suggest that the two first PC explains most of the variation.
#'
#+ save2, include=FALSE
#ggsave(paste(params$workingDirectory,params$resultsDirectory, "PCAvariance.png", sep = "/"))
#'
#'
pctable = as.data.frame(mir.pca$x)[, 1:5]
pctable = cbind(pctable, sampleInfo)
test  = plotPCAplot(PCAinfo = pctable, n.comp = 4,
varianceInfo = e.var,
colorComponent = "Genotype",pchComponent = "Time"
)
test
mean = pctable %>% dplyr::select(PC1,PC2,PC3,Genotype) %>%
dplyr::group_by(Genotype) %>%
dplyr::summarise(PC1 = mean(PC1) ,PC2 = mean(PC2), PC3 = mean(PC3) )
# Original code
# origo = data.frame(PC2=0, PC3 = 0)
# line.gd7 = rbind(mean[1,3:4],origo,-mean[1,3:4])
# line.gd7$factor = "Gd7"
# line.toll10b = rbind(mean[2,3:4],origo,-mean[2,3:4])
# line.toll10b$factor = "Toll10b"
# line.toll9 = rbind(mean[3,3:4],origo,-mean[3,3:4])
# line.toll9$factor = "Toll9"
# Changed here to include PC1
origo = data.frame(PC1=0,PC2=0, PC3 = 0)
line.gd7 = rbind(mean[1,2:4],origo,-mean[1,2:4])
line.gd7$factor = "Gd7"
line.toll10b = rbind(mean[2,2:4],origo,-mean[2,2:4])
line.toll10b$factor = "Toll10b"
line.toll9 = rbind(mean[3,2:4],origo,-mean[3,2:4])
line.toll9$factor = "Toll9"
line = rbind(line.gd7,line.toll10b,line.toll9)
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
ggplot(line, mapping = aes(x = PC1,y = PC2, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC1,y = PC2, color = Genotype, shape = Time))
ggplot(line, mapping = aes(x = PC2,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC2,y = PC3, color = Genotype, shape = Time))
ggplot(line, mapping = aes(x = PC1,y = PC3, color = factor))+ geom_line() + geom_point(data = pctable,  mapping = aes(x = PC1,y = PC3, color = Genotype, shape = Time))
View(pctable)
View(mean)
View(pctable)
knitr::opts_chunk$set(echo = TRUE)
#BiocManager::install("clusterProfiler")
#BiocManager::install("org.Dm.eg.db")
#install.packages("ggrepel")
#install.packages("kableExtra")
#install.packages("heatmap3")
#install.packages("tsne")
#install.packages("umap")
library(umap)
library(clusterProfiler)
library(org.Dm.eg.db)
library(tidyverse)
library(gplots)
library(knitr)
library(kableExtra)
library("viridis")
library(heatmap3)
library(ggrepel)
library(tsne)
# Loading the gtf file to extract annotation.
gtfFile = paste(params$workingDir, "Drosophila_melanogaster.BDGP6.28.101.gtf", sep = "/")
gtfInfo = read.table(file = gtfFile, header = F, sep = "\t", quote = "", stringsAsFactors = F)
# Chosing only the annotation for genes
gtfInfoGene = gtfInfo %>% dplyr::filter(V3 == "gene")
# Extract only gene name and geneID
gtfInfoGene = gtfInfoGene[grep(pattern = "gene_biotype \"protein_coding\"",x = gtfInfoGene$V9 ),  ]
gtfInfoGene= gtfInfoGene %>% separate(col = V9,sep = ";",into =  c("geneID1", "geneName1", "gene_source", "gene_biotype", "empty"))
gtfInfoGene= gtfInfoGene %>% separate(col = geneID1,sep = "\"",into =  c("irrelevant", "geneID", "empty"))
gtfInfoGene= gtfInfoGene %>% separate(col = geneName1,sep = "\"",into =  c("irrelevant1", "geneName", "empty"))
#gtfInfoGene = gtfInfoGene$geneID
###### Contiune to fix the data frame gtfInfoGene
gtfInfoAnnotation = gtfInfoGene  %>% select(V1,V4,V5,V7,geneID,geneName)
BiocManager::install("clusterProfiler")
BiocManager::install("org.Dm.eg.db")
install.packages("ggrepel")
install.packages("kableExtra")
install.packages("heatmap3")
install.packages("tsne")
install.packages("umap")
